对下列程序进行了部分注释：


/*用户user代码*/
///////////////////////////////////////////（1）逆动力学控制器////////////////////////////////////////////
文件位置：user\Example_Leg_InvDyn文件夹
（1）计算腿部关节你动力学解算，最终输出每个关节的力矩


///////////////////////////////////////////（2）关节电机控制器////////////////////////////////////////////
文件位置：user\JPos_Controller文件夹
（1）设定KP\KD反馈矩阵参数，并发布每个关节发布位置、速度、力矩、及对应KP\KD五个参数


///////////////////////////////////////////（3）SPI通讯控制器////////////////////////////////////////////
文件位置：user\MiniCheetahSpi_Controller文件夹
（1）发送每个关节的期望位置、KP、KD三个参数



///////////////////////////////////////////（4）MIT所有的控制器/////////////////////////////////////////////

///////////////////////////////////////////（4.1）pc上的启动文件////////////////////////////////////////////
文件位置：user\MIT_Controller\main.cpp
（1）pc上所有程序的启动文件


///////////////////////////////////////////（4.2）运行运动控制程序///////////////////////////////////////////
文件位置：user\MIT_Controller\main.cpp
（1）运行运动控制程序，包括：查找当前步态状态、找到想要的状态轨迹、运行控制FSM代码


///////////////////////////////////////////（4.3）有限状态机////////////////////////////////////////////
文件位置：user\MIT_Controller\FSM_States
（1）FSM有限状态机，根据状态不同使用不同的控制器，不同的状态控制器有对应的C++/h文件
（2）状态机的状态切换有四个，NORMAL, TRANSITIONING, ESTOP, EDAMP，运行状态机的四个对应代码在ControlFSM.cpp->runFSM()中
（3）对应的状态控制器状态如下。有11种，状态机切换的目标状态 即实现的功能
/*struct FSM_StatesList 
{
  FSM_State<T>* invalid;                             // 空 
  FSM_State_Passive<T>* passive;                     //无操作，人为手动操纵机器人
  FSM_State_JointPD<T>* jointPD;                     //独立关节控制
  FSM_State_ImpedanceControl<T>* impedanceControl;   //独立控制 应该时直角坐标下
  FSM_State_StandUp<T>* standUp;                     //站起
  FSM_State_BalanceStand<T>* balanceStand;           //平衡站立
  FSM_State_Locomotion<T>* locomotion;               //移动
  FSM_State_RecoveryStand<T>* recoveryStand;         //恢复站立
  FSM_State_Vision<T>* vision;                       //视觉
  FSM_State_BackFlip<T>* backflip;                   //后空翻
  FSM_State_FrontJump<T>* frontJump;                 //前跳
};
*/
（4）状态机可以通过遥控在这些状态间切换，猜测应包含大量调试用状态
（5）这些FSM的状态C++、h文件的函数和格式都是一样的，所以调用方法都是一样的
（6）每进行一次动作，都会进行一次安全性检查，包括检查方位角、脚的位置、垂直力\侧向力三个方面的检查


///////////////////////////////////////////（4.4）运动控制算法的控制器（很重要）////////////////////////////////////////////
文件位置：user\MIT_Controller\FSM_States

（4.4.1）后空翻控制器：       后空翻动作是实现+数据读取+前跳动作       
（4.4.2）平衡控制器：         两种方法的QP平衡控制器实现+参考的反作用力计算
（4.4.3）MPC控制器：          里面有新的算法
（4.4.4）WBC控制器：          里面是旧的算法，可以对比看看
（4.4.5）WBC_Ctrl控制器

MPC控制器和WBC控制器种WBC种有相似的部分















/*机器人robot代码*/
///////////////////////////////////////////（1）通讯的硬件协议实现：以太网、手柄sbus、串口、SPI等////////////////////////////////////////////
文件位置：robot\src\rt\
（1）以太网、手柄sbus、串口、SPI的初始化（端口、通讯速率等）、发送，接收、校验程序

注意：大都是通讯底层协议的实现，库开发的

///////////////////////////////////////////（2）硬件接口程序：启动控制器 通信等////////////////////////////////////////////
文件位置：robot\src\HardwareBridge.cpp
（1）LCM通讯和线程：    两条狗对应的LCM通讯和线程优先级初始化
（2）以太网:           通过以太网LCM通讯，发送四条腿自定义消息
（3）IMU:              初始化IMU，接收IMU的数据
（4）SPI：             初始化SPI，SPI通讯
（5）SBUS接收RC：      手柄命令设置，用SBUS接收RC，通过接收到的手柄数据，设置移动参数、模式
（6）初始化特定硬件：   初始化Mini Cheetah，Cheetah 3的特定硬件

注意：只要是通讯相关的都靠LCM发布和接收


///////////////////////////////////////////（3）电机关节初始化////////////////////////////////////////////
文件位置：robot\src\JPosInitializer.cpp
（1）电机关节初始化


///////////////////////////////////////////（4）真实环境下，周期运行器，将运行框架加入任务管理器/////////////////////////
***
文件位置：robot\src\RobotRunner.cpp
（1）初始化机器人模型，状态估计器，腿部控制器，机器人数据，以及任何控制逻辑特定的数据
（2）将运行框架加入任务管理器--实例化运行器 传入控制器，任务管理器 参数 名称 

备注：运行器：用来运行状态估计、控制器等，运行器是一个周期任务

///////////////////////////////////////////（5）仿真环境下////////////////////////////////////////////
文件位置：robot\src\SimulationBridge.cpp
（1）运行手柄RC receive线程
（2）处理来自模拟器的控制参数消息
（3）连接到仿真函数，默认运行四足动物控制器
（4）运行机器人控制器

///////////////////////////////////////////（6）upboard上的启动文件////////////////////////////////////////////
文件位置：robot\main_helper

（1）启动upboard的所有程序







////////////////周期任务/运行器////////////////////
PeriodicTask//周期任务




///////////////状态估计/////////////////
StateEstimator//状态估计父类
common\include\Controllers\StateEstimatorContainer.h

ContactEstimator//接触状态估计 目前版本代码未使用论文中算法 只是直接传递数据

PositionVelocityEstimator//位置估计 卡尔曼滤波 

orientationEstimator //角度估计 

contactEstimator //接触状态估计 目前为使用到 当前功能为将步态时间表传递











/////////////////控制器////////////////////////////////////////
RobotController//控制器父类 仅用来继承创造接口


VisionMPC//老版本MPC算法 主要部分和convexMPC相同
convexMPC//实际使用的mpc算法

FootSwingTrajectory//足端轨迹

BalanceController//为QP优化实现虚拟力分配，实际好像未使用？ 在FSM_State<T>* invalid;中使用，这个被设为空指针了

LegController//腿部控制 包括单腿雅可比 运动学 向控制板收发命令和参数  所有的量都在“腿坐标系”中，与身体坐标系有相同的方向





PC整体流程流程
/*
(1)->user\main.cpp是启动文件传入控制器对象MIT_Controller
(2)->启动main_helper
(3)->启动hardwarebridge
(4)->启动周期任务控制器PeriodicTask
(5)->添加robotrunner到任务管理器
(6)->robotrunner启动MIT_Controller,实例化需要的类传入MIT_Controller
(7)->MIT_Controller启动DesiredStateCommand。。。
(8)->MIT_Controller启动gait_schedule.。。
(9)->MIT_Controller启动Estimator。。。
(10)->MIT_Controller启动支撑相控制\摆动相控制
(11)->MIT_Controller启动ControlFSM进行状态切换
*/

Robot整体流程
/*
（1）SPI收发
（2）以太网收发
（3）手柄串口收发
（）
*/

sim整体流程
/*
（1）QT
（2）界面可视化
*/


MCU整体流程
/*
-------------------通讯板---------------------
（1）SPI收发
（2）CAN收发

-------------------电源板---------------------
(1)电机报警断电

-------------------驱动板---------------------
（1）CAN收发
（2）FOC算法
（3）串口收发
*/
